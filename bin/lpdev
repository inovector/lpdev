#!/bin/bash

# Configuration file location
CONFIG_DIR="$HOME/.lpdev"
CONFIG_FILE="$CONFIG_DIR/projects.json"
CURRENT_PROJECT_FILE="$CONFIG_DIR/current_project"
PLUGINS_DIR="$CONFIG_DIR/plugins"
PLUGINS_ENABLED_DIR="$PLUGINS_DIR/enabled"
PLUGINS_AVAILABLE_DIR="$PLUGINS_DIR/available"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Get script directory for sourcing modules - handle symlinks correctly
if [ -L "$0" ]; then
    # If this script is a symlink, follow it to find the real location
    REAL_SCRIPT="$(readlink "$0")"
    # Handle relative symlinks
    if [[ "$REAL_SCRIPT" != /* ]]; then
        REAL_SCRIPT="$(dirname "$0")/$REAL_SCRIPT"
    fi
    SCRIPT_DIR="$(cd "$(dirname "$REAL_SCRIPT")" && pwd)"
else
    # Not a symlink, use normal method
    SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
fi

# Source utility modules
source "$SCRIPT_DIR/../lib/utils.sh"
source "$SCRIPT_DIR/../lib/project.sh" 
source "$SCRIPT_DIR/../lib/server.sh"

# Initialize configuration
init_config() {
    if [ ! -d "$CONFIG_DIR" ]; then
        mkdir -p "$CONFIG_DIR"
        echo "[]" > "$CONFIG_FILE"
        touch "$CURRENT_PROJECT_FILE"
    fi
    
    # Initialize plugin directories
    mkdir -p "$PLUGINS_ENABLED_DIR" "$PLUGINS_AVAILABLE_DIR"
}

# Plugin system functions
load_plugins() {
    if [ -d "$PLUGINS_ENABLED_DIR" ]; then
        for plugin in "$PLUGINS_ENABLED_DIR"/*.plugin; do
            if [ -f "$plugin" ] || [ -L "$plugin" ]; then
                source "$plugin" 2>/dev/null || print_warning "Failed to load plugin: $(basename "$plugin")"
            fi
        done
    fi
}

call_plugin_hook() {
    local hook_name="$1"
    shift
    
    # Call the hook function if it exists
    if declare -f "$hook_name" > /dev/null; then
        "$hook_name" "$@"
    fi
}

# Plugin management functions
plugin_list() {
    print_header "Installed Plugins"
    
    echo -e "${BOLD}Available Plugins:${NC}"
    if [ -d "$PLUGINS_AVAILABLE_DIR" ]; then
        local has_plugins=false
        
        # List file-based plugins
        for plugin in "$PLUGINS_AVAILABLE_DIR"/*.plugin; do
            if [ -f "$plugin" ]; then
                has_plugins=true
                local plugin_name=$(basename "$plugin" .plugin)
                local enabled=""
                
                if [ -L "$PLUGINS_ENABLED_DIR/$plugin_name.plugin" ] || [ -f "$PLUGINS_ENABLED_DIR/$plugin_name.plugin" ]; then
                    enabled=" ${GREEN}[enabled]${NC}"
                fi
                
                echo -e "  - ${plugin_name}${enabled}"
            fi
        done
        
        # List npm-installed plugins
        if [ -d "$PLUGINS_AVAILABLE_DIR/node_modules" ]; then
            for plugin_dir in "$PLUGINS_AVAILABLE_DIR/node_modules"/lpdev-plugin-*; do
                if [ -d "$plugin_dir" ]; then
                    has_plugins=true
                    local plugin_name=$(basename "$plugin_dir" | sed 's/lpdev-plugin-//')
                    local version=$(grep '"version"' "$plugin_dir/package.json" 2>/dev/null | cut -d'"' -f4)
                    local enabled=""
                    
                    if [ -L "$PLUGINS_ENABLED_DIR/$plugin_name.plugin" ] || [ -f "$PLUGINS_ENABLED_DIR/$plugin_name.plugin" ]; then
                        enabled=" ${GREEN}[enabled]${NC}"
                    fi
                    
                    echo -e "  - ${plugin_name} (v${version})${enabled} ${CYAN}[npm]${NC}"
                fi
            done
        fi
        
        if [ "$has_plugins" = false ]; then
            echo "  No plugins installed"
        fi
    else
        echo "  No plugins directory found"
    fi
    
    echo ""
    echo -e "${BOLD}Install plugins with:${NC} lpdev plugin install <name>"
    echo -e "${BOLD}Enable plugins with:${NC} lpdev plugin enable <name>"
}

plugin_install() {
    local plugin_name="$1"
    
    if [ -z "$plugin_name" ]; then
        print_error "Plugin name required. Usage: lpdev plugin install <name>"
        return 1
    fi
    
    print_info "Installing plugin: $plugin_name"
    
    # Create plugins directory if it doesn't exist
    mkdir -p "$PLUGINS_AVAILABLE_DIR"
    
    # Check if it's an npm package
    cd "$PLUGINS_AVAILABLE_DIR"
    
    # Initialize npm if package.json doesn't exist
    if [ ! -f "package.json" ]; then
        npm init -y > /dev/null 2>&1
    fi
    
    # Try to install from npm
    local npm_package="lpdev-plugin-$plugin_name"
    
    print_info "Searching npm for: $npm_package"
    
    if npm view "$npm_package" > /dev/null 2>&1; then
        print_info "Found npm package: $npm_package"
        npm install "$npm_package"
        
        if [ $? -eq 0 ]; then
            # Create symlink to plugin file
            if [ -f "node_modules/$npm_package/index.plugin" ]; then
                ln -sf "node_modules/$npm_package/index.plugin" "$plugin_name.plugin"
                print_success "Plugin '$plugin_name' installed successfully!"
                print_info "Enable it with: lpdev plugin enable $plugin_name"
            else
                print_error "Plugin installed but index.plugin not found"
            fi
        else
            print_error "Failed to install plugin from npm"
        fi
    else
        print_error "Plugin '$npm_package' not found on npm"
        print_info "Try searching with: lpdev plugin search $plugin_name"
    fi
}

plugin_uninstall() {
    local plugin_name="$1"
    
    if [ -z "$plugin_name" ]; then
        print_error "Plugin name required. Usage: lpdev plugin uninstall <name>"
        return 1
    fi
    
    print_info "Uninstalling plugin: $plugin_name"
    
    # Disable plugin first
    plugin_disable "$plugin_name"
    
    # Remove npm package if it exists
    if [ -d "$PLUGINS_AVAILABLE_DIR/node_modules/lpdev-plugin-$plugin_name" ]; then
        cd "$PLUGINS_AVAILABLE_DIR"
        npm uninstall "lpdev-plugin-$plugin_name"
    fi
    
    # Remove symlink
    if [ -L "$PLUGINS_AVAILABLE_DIR/$plugin_name.plugin" ]; then
        rm "$PLUGINS_AVAILABLE_DIR/$plugin_name.plugin"
    fi
    
    print_success "Plugin '$plugin_name' uninstalled"
}

plugin_enable() {
    local plugin_name="$1"
    
    if [ -z "$plugin_name" ]; then
        print_error "Plugin name required. Usage: lpdev plugin enable <name>"
        return 1
    fi
    
    # Check if plugin is available
    if [ ! -f "$PLUGINS_AVAILABLE_DIR/$plugin_name.plugin" ] && [ ! -L "$PLUGINS_AVAILABLE_DIR/$plugin_name.plugin" ]; then
        print_error "Plugin '$plugin_name' not found in available plugins"
        print_info "Install it first with: lpdev plugin install $plugin_name"
        return 1
    fi
    
    # Create enabled directory if it doesn't exist
    mkdir -p "$PLUGINS_ENABLED_DIR"
    
    # Create symlink to enable plugin
    ln -sf "../available/$plugin_name.plugin" "$PLUGINS_ENABLED_DIR/$plugin_name.plugin"
    
    print_success "Plugin '$plugin_name' enabled"
}

plugin_disable() {
    local plugin_name="$1"
    
    if [ -z "$plugin_name" ]; then
        print_error "Plugin name required. Usage: lpdev plugin disable <name>"
        return 1
    fi
    
    # Remove symlink from enabled directory
    if [ -L "$PLUGINS_ENABLED_DIR/$plugin_name.plugin" ] || [ -f "$PLUGINS_ENABLED_DIR/$plugin_name.plugin" ]; then
        rm "$PLUGINS_ENABLED_DIR/$plugin_name.plugin"
        print_success "Plugin '$plugin_name' disabled"
    else
        print_info "Plugin '$plugin_name' was not enabled"
    fi
}

plugin_search() {
    local search_term="$1"
    
    if [ -z "$search_term" ]; then
        print_info "Searching for all lpdev plugins..."
        npm search "lpdev-plugin"
    else
        print_info "Searching for: $search_term"
        npm search "lpdev-plugin-$search_term"
    fi
}

plugin_help() {
    echo -e "${BOLD}${BLUE}Plugin Management${NC}

${BOLD}USAGE:${NC}
    lpdev plugin <command> [options]

${BOLD}COMMANDS:${NC}
    ${GREEN}list${NC}              List installed plugins
    ${GREEN}install${NC} <name>    Install plugin from npm
    ${GREEN}uninstall${NC} <name>  Remove installed plugin
    ${GREEN}enable${NC} <name>     Enable an installed plugin
    ${GREEN}disable${NC} <name>    Disable a plugin
    ${GREEN}search${NC} [term]     Search npm for plugins
    ${GREEN}<name>${NC} <cmd>      Execute plugin command

${BOLD}EXAMPLES:${NC}
    lpdev plugin list                    # Show all installed plugins
    lpdev plugin install mixpost         # Install lpdev-plugin-mixpost from npm
    lpdev plugin enable mixpost          # Enable the mixpost plugin
    lpdev plugin disable mixpost         # Disable the mixpost plugin
    lpdev plugin search                  # Search all lpdev plugins on npm
    lpdev plugin mixpost status          # Run mixpost plugin command"
}

# Project management functions
add_project() {
    print_header "Add New Project"
    
    echo -n "Project name: "
    read project_name
    
    # Get and validate Laravel app path
    while true; do
        echo -n "Laravel app path (absolute or relative): "
        read app_path_input
        
        if [ ! -d "$app_path_input" ]; then
            print_error "Laravel app path does not exist: $app_path_input"
            continue
        fi
        
        # Convert to absolute path after validation
        app_path=$(realpath "$app_path_input" 2>/dev/null || echo "$app_path_input")
        
        # Double-check the resolved path exists
        if [ ! -d "$app_path" ]; then
            print_error "Resolved Laravel app path does not exist: $app_path"
            continue
        fi
        
        break
    done
    
    # Get and validate package path
    while true; do
        echo -n "Package local development path: "
        read package_path_input
        
        if [ ! -d "$package_path_input" ]; then
            print_error "Package path does not exist: $package_path_input"
            continue
        fi
        
        # Convert to absolute path after validation
        package_path=$(realpath "$package_path_input" 2>/dev/null || echo "$package_path_input")
        
        # Double-check the resolved path exists
        if [ ! -d "$package_path" ]; then
            print_error "Resolved package path does not exist: $package_path"
            continue
        fi
        
        break
    done
    
    echo -n "Package vendor name (e.g., vendor/your-package-name): "
    read package_vendor
    
    # Get APP_URL - try to extract from existing .env files or ask user
    local app_url=""
    local default_app_url=""
    
    # Try to extract from app .env first
    if [ -f "$app_path/.env" ]; then
        default_app_url=$(grep "^APP_URL=" "$app_path/.env" | cut -d'=' -f2- | tr -d '"' 2>/dev/null)
    fi
    
    # If not found in app, try package .env
    if [ -z "$default_app_url" ] && [ -f "$package_path/.env" ]; then
        default_app_url=$(grep "^APP_URL=" "$package_path/.env" | cut -d'=' -f2- | tr -d '"' 2>/dev/null)
    fi
    
    # Ask user for APP_URL
    if [ -n "$default_app_url" ]; then
        echo -n "APP_URL (default: $default_app_url): "
        read app_url
        if [ -z "$app_url" ]; then
            app_url="$default_app_url"
        fi
    else
        echo -n "APP_URL (e.g., http://localhost:8000 or https://myapp.test): "
        read app_url
    fi
    
    # Add to config using Python (more reliable for JSON manipulation)
    python3 << EOF
import json
import os

config_file = "$CONFIG_FILE"
with open(config_file, 'r') as f:
    projects = json.load(f)

# Check if project already exists
if any(p['name'] == "$project_name" for p in projects):
    print("Project already exists!")
    exit(1)

projects.append({
    "name": "$project_name",
    "app_path": "$app_path",
    "package_path": "$package_path",
    "package_vendor": "$package_vendor",
    "package_vendor_path": "$app_path/vendor/${package_vendor}"
})

with open(config_file, 'w') as f:
    json.dump(projects, f, indent=2)
EOF
    
    if [ $? -eq 0 ]; then
        print_success "Project '$project_name' added successfully!"
        
        # Set as current if it's the first project
        if [ ! -s "$CURRENT_PROJECT_FILE" ]; then
            echo "$project_name" > "$CURRENT_PROJECT_FILE"
            print_info "Set as current project"
        fi
        
        # Set APP_URL in both .env files if provided
        if [ -n "$app_url" ]; then
            print_info "Setting up environment variables..."
            
            
            # Set APP_URL in app .env
            set_env_var "$app_path/.env" "APP_URL" "$app_url"
            print_success "App: APP_URL=$app_url"
            
            # Set APP_URL in package .env if it exists
            if [ -f "$package_path/.env" ]; then
                set_env_var "$package_path/.env" "APP_URL" "$app_url"
                print_success "Package: APP_URL=$app_url"
            fi
            
            # Call plugin hook for project creation
            call_plugin_hook "on_project_add" "$project_name" "$app_url" "$app_path" "$package_path"
        fi
    else
        print_error "Failed to add project"
    fi
}

list_projects() {
    print_header "Available Projects"
    
    current=$(cat "$CURRENT_PROJECT_FILE" 2>/dev/null)
    
    python3 << EOF
import json

with open("$CONFIG_FILE", 'r') as f:
    projects = json.load(f)

if not projects:
    print("No projects configured. Use 'lpdev add' to add a project.")
else:
    for i, p in enumerate(projects, 1):
        marker = "►" if p['name'] == "$current" else " "
        print(f"{marker} {i}. {p['name']}")
        print(f"     App: {p['app_path']}")
        print(f"     Package: {p['package_path']}")
        print(f"     Vendor: {p['package_vendor']}")
        print()
EOF
}

switch_project() {
    list_projects
    
    echo -n "Enter project name or number: "
    read selection
    
    project_name=$(python3 << EOF
import json

with open("$CONFIG_FILE", 'r') as f:
    projects = json.load(f)

selection = "$selection"

# Check if selection is a number
try:
    index = int(selection) - 1
    if 0 <= index < len(projects):
        print(projects[index]['name'])
    else:
        print("ERROR: Invalid number")
except ValueError:
    # Selection is a name
    for p in projects:
        if p['name'] == selection:
            print(p['name'])
            break
    else:
        print("ERROR: Project not found")
EOF
)
    
    if [[ $project_name == ERROR:* ]]; then
        print_error "${project_name#ERROR: }"
    else
        echo "$project_name" > "$CURRENT_PROJECT_FILE"
        print_success "Switched to project: $project_name"
    fi
}

remove_project() {
    list_projects
    
    echo -n "Enter project name to remove: "
    read project_name
    
    echo -n "Are you sure you want to remove '$project_name'? (y/N): "
    read confirm
    
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
        print_info "Cancelled"
        return
    fi
    
    python3 << EOF
import json

with open("$CONFIG_FILE", 'r') as f:
    projects = json.load(f)

projects = [p for p in projects if p['name'] != "$project_name"]

with open("$CONFIG_FILE", 'w') as f:
    json.dump(projects, f, indent=2)
EOF
    
    print_success "Project removed"
    
    # Clear current if it was removed
    if [ "$(cat "$CURRENT_PROJECT_FILE" 2>/dev/null)" == "$project_name" ]; then
        > "$CURRENT_PROJECT_FILE"
    fi
}

set_project_env() {
    local key="$1"
    local value="$2"
    
    if [ -z "$key" ]; then
        print_error "Environment variable key is required"
        echo "Usage: lpdev env-set <KEY> <VALUE>"
        return 1
    fi
    
    eval $(get_current_project) || return 1
    
    print_info "Setting $key='$value' for project $LPDEV_PROJECT"
    
    python3 << EOF
import json

with open("$CONFIG_FILE", 'r') as f:
    projects = json.load(f)

for project in projects:
    if project['name'] == "$LPDEV_PROJECT":
        if 'env_vars' not in project:
            project['env_vars'] = {}
        project['env_vars']["$key"] = "$value"
        break

with open("$CONFIG_FILE", 'w') as f:
    json.dump(projects, f, indent=2)

print("Environment variable set successfully")
EOF
}

remove_project_env() {
    local key="$1"
    
    if [ -z "$key" ]; then
        print_error "Environment variable key is required"
        echo "Usage: lpdev env-remove <KEY>"
        return 1
    fi
    
    eval $(get_current_project) || return 1
    
    print_info "Removing $key from project $LPDEV_PROJECT"
    
    python3 << EOF
import json

with open("$CONFIG_FILE", 'r') as f:
    projects = json.load(f)

for project in projects:
    if project['name'] == "$LPDEV_PROJECT":
        if 'env_vars' in project and "$key" in project['env_vars']:
            del project['env_vars']["$key"]
            print("Environment variable '$key' removed successfully")
        else:
            print("Environment variable '$key' not found")
        break

with open("$CONFIG_FILE", 'w') as f:
    json.dump(projects, f, indent=2)
EOF
}

list_project_env() {
    eval $(get_current_project) || return 1
    
    print_header "Environment Variables"
    
    python3 << EOF
import json

with open("$CONFIG_FILE", 'r') as f:
    projects = json.load(f)

for project in projects:
    if project['name'] == "$LPDEV_PROJECT":
        env_vars = project.get('env_vars', {})
        if env_vars:
            for key, value in env_vars.items():
                print(f"  {key}={value}")
        else:
            print("  No environment variables set")
        break
EOF
}

get_project_env() {
    local key="$1"
    
    if [ -z "$key" ]; then
        return 1
    fi
    
    eval $(get_current_project) || return 1
    
    python3 << EOF
import json
import sys

with open("$CONFIG_FILE", 'r') as f:
    projects = json.load(f)

for project in projects:
    if project['name'] == "$LPDEV_PROJECT":
        env_vars = project.get('env_vars', {})
        if "$key" in env_vars:
            print(env_vars["$key"])
            sys.exit(0)
        break

sys.exit(1)
EOF
}

link_package() {
    eval $(get_current_project) || return 1
    
    call_plugin_hook "before_link_package" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
    
    print_info "Linking package for project: $LPDEV_PROJECT"
    
    cd "$LPDEV_APP_PATH"
    
    # Get package name from package's composer.json
    package_name=$(get_package_name "$LPDEV_PACKAGE_PATH")
    
    if [ -z "$package_name" ]; then
        print_error "Could not get package name from composer.json at: $LPDEV_PACKAGE_PATH/composer.json"
        return 1
    fi
    
    print_info "Package name: $package_name"
    
    # Get current branch from package git repo
    branch_name=$(get_current_git_branch "$LPDEV_PACKAGE_PATH")
    
    # Extract git branch name from dev-branch format for display
    git_branch_display=${branch_name#dev-}
    if [ "$git_branch_display" != "main" ]; then
        print_info "Detected git branch: $git_branch_display -> Using: $branch_name"
    else
        print_info "Using default branch: $branch_name"
    fi
    
    cd "$LPDEV_APP_PATH"
    
    # Calculate relative path from app to package
    relative_path=$(python3 << EOF
import os
app_path = "$LPDEV_APP_PATH"
package_path = "$LPDEV_PACKAGE_PATH"
print(os.path.relpath(package_path, app_path))
EOF
)
    
    print_info "Relative path: $relative_path"
    
    # Update composer.json to add path repository and require the package
    python3 << EOF
import json
import os

# Read current composer.json
with open("composer.json", 'r') as f:
    composer_data = json.load(f)

# Add repositories section if it doesn't exist
if 'repositories' not in composer_data:
    composer_data['repositories'] = []

# Remove any existing repository with the same URL
composer_data['repositories'] = [
    repo for repo in composer_data['repositories'] 
    if not (repo.get('type') == 'path' and repo.get('url') == "$relative_path")
]

# Add the new path repository
composer_data['repositories'].append({
    "type": "path",
    "url": "$relative_path"
})

# Add or update the package in require section
if 'require' not in composer_data:
    composer_data['require'] = {}

composer_data['require']['$package_name'] = '$branch_name'

# Write back to composer.json
with open("composer.json", 'w') as f:
    json.dump(composer_data, f, indent=4)
EOF
    
    print_success "Added path repository and package requirement to composer.json"
    print_info "Repository: $relative_path"
    print_info "Requirement: $package_name: $branch_name"
    
    # Run composer install to apply changes
    print_info "Running composer install..."
    composer install
    
    if [ $? -eq 0 ]; then
        print_success "Package linked successfully via Composer path repository!"
    else
        print_error "Composer install failed"
        return 1
    fi
    
    call_plugin_hook "after_link_package" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
}

unlink_package() {
    eval $(get_current_project) || return 1
    
    call_plugin_hook "before_unlink_package" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
    
    print_info "Unlinking package for project: $LPDEV_PROJECT"
    
    cd "$LPDEV_APP_PATH"
    
    # Get package name from package's composer.json
    package_name=$(get_package_name "$LPDEV_PACKAGE_PATH")
    
    if [ -z "$package_name" ]; then
        print_error "Could not get package name from composer.json at: $LPDEV_PACKAGE_PATH/composer.json"
        return 1
    fi
    
    print_info "Package name: $package_name"
    
    # Calculate relative path from app to package
    relative_path=$(python3 << EOF
import os
app_path = "$LPDEV_APP_PATH"
package_path = "$LPDEV_PACKAGE_PATH"
print(os.path.relpath(package_path, app_path))
EOF
)
    
    # Remove path repository and package requirement from composer.json
    python3 << EOF
import json
import os

# Read current composer.json
with open("composer.json", 'r') as f:
    composer_data = json.load(f)

# Remove the path repository if it exists
if 'repositories' in composer_data:
    composer_data['repositories'] = [
        repo for repo in composer_data['repositories'] 
        if not (repo.get('type') == 'path' and repo.get('url') == "$relative_path")
    ]
    
    # Remove empty repositories array
    if not composer_data['repositories']:
        del composer_data['repositories']

# Remove the package from require section
if 'require' in composer_data and '$package_name' in composer_data['require']:
    del composer_data['require']['$package_name']

# Write back to composer.json
with open("composer.json", 'w') as f:
    json.dump(composer_data, f, indent=4)
EOF
    
    print_success "Removed path repository and package requirement from composer.json"
    print_info "Repository removed: $relative_path"
    print_info "Package requirement removed: $package_name"
    
    # Remove vendor directory and run composer install to restore original packages
    print_info "Removing vendor directory and running composer install..."
    rm -rf vendor
    composer install
    
    if [ $? -eq 0 ]; then
        print_success "Package unlinked and restored from composer repositories"
    else
        print_error "Composer install failed"
        return 1
    fi
    
    call_plugin_hook "after_unlink_package" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
}

switch_branch() {
    eval $(get_current_project) || return 1
    
    call_plugin_hook "before_switch_branch" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH" "$1"
    
    # Check if branch name was provided as argument
    local branch="$1"
    
    # If no branch provided, try to detect from git
    if [ -z "$branch" ]; then
        # Use existing get_current_git_branch function
        branch=$(get_current_git_branch "$LPDEV_PACKAGE_PATH")
        
        # Extract git branch name from dev-branch format for display
        local git_branch_display=${branch#dev-}
        if [ "$git_branch_display" != "main" ]; then
            print_info "Detected git branch: $git_branch_display -> Using: $branch"
        else
            print_info "Using default branch: $branch"
        fi
    fi
    
    if [ -z "$branch" ]; then
        print_error "No branch specified"
        return 1
    fi
    
    cd "$LPDEV_APP_PATH"
    
    print_info "Switching to branch: $branch"
    
    # Update composer.json
    sed -i.bak "s|\"$LPDEV_PACKAGE_VENDOR\": \".*\"|\"$LPDEV_PACKAGE_VENDOR\": \"$branch\"|" composer.json
    rm composer.json.bak
    
    composer update "$LPDEV_PACKAGE_VENDOR"
    
    print_success "Switched to branch: $branch"
    
    call_plugin_hook "after_switch_branch" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH" "$branch"
}

install_deps() {
    eval $(get_current_project) || return 1

    print_header "Installing Dependencies for $LPDEV_PROJECT"

    call_plugin_hook "before_install_deps" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
    
    # Install app dependencies
    print_info "Installing app dependencies..."
    cd "$LPDEV_APP_PATH"
    rm -rf vendor
    composer install
    
    # Install package dependencies
    print_info "Installing package dependencies..."
    cd "$LPDEV_PACKAGE_PATH"
    rm -rf vendor node_modules
    composer install
    npm install
    
    call_plugin_hook "after_install_deps" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"

    print_success "All dependencies installed!"
}

fresh_install() {
    eval $(get_current_project) || return 1
    
    print_header "Fresh Install for $LPDEV_PROJECT"

    call_plugin_hook "before_fresh_install" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
    
    # Step 1: Link package
    print_info "Step 1/6: Linking package..."
    link_package
    
    # Step 2: Set current branch automatically
    print_info "Step 2/6: Setting branch from git..."
    local branch=$(get_current_git_branch "$LPDEV_PACKAGE_PATH")
    
    # Extract git branch name from dev-branch format for display
    local git_branch_display=${branch#dev-}
    if [ "$git_branch_display" != "main" ]; then
        print_info "Detected git branch: $git_branch_display -> Using: $branch"
    else
        print_info "Using default branch: $branch"
    fi
    
    cd "$LPDEV_APP_PATH"
    sed -i.bak "s|\"$LPDEV_PACKAGE_VENDOR\": \".*\"|\"$LPDEV_PACKAGE_VENDOR\": \"$branch\"|" composer.json
    rm composer.json.bak
    
    # Step 3: Remove vendor and node_modules from app
    print_info "Step 3/6: Cleaning app dependencies..."
    cd "$LPDEV_APP_PATH"
    [ -d "vendor" ] && rm -rf vendor
    [ -d "node_modules" ] && rm -rf node_modules
    
    # Step 4: Remove vendor and node_modules from package
    print_info "Step 4/6: Cleaning package dependencies..."
    cd "$LPDEV_PACKAGE_PATH"
    [ -d "vendor" ] && rm -rf vendor
    [ -d "node_modules" ] && rm -rf node_modules
    
    # Step 5: Install dependencies
    print_info "Step 5/6: Installing dependencies..."
    
    # Install package dependencies (PHP + JS)
    print_info "Installing package dependencies (PHP + JS)..."
    cd "$LPDEV_PACKAGE_PATH"
    if [ -f "composer.json" ]; then
        composer install
    fi
    if [ -f "package.json" ]; then
        npm install
    fi
    
    # Install app dependencies (PHP only)
    print_info "Installing app dependencies (PHP only)..."
    cd "$LPDEV_APP_PATH"
    composer install
    
    # Step 6: Clear Laravel optimizations
    print_info "Step 6/6: Clearing Laravel cache..."
    cd "$LPDEV_APP_PATH"
    php artisan optimize:clear

    call_plugin_hook "after_fresh_install" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
    
    print_success "Fresh install completed successfully!"
    print_info "Package linked, dependencies installed, and Laravel cache cleared"
    
    # Display APP_URL
    if [ -f "$LPDEV_APP_PATH/.env" ]; then
        app_url=$(grep "^APP_URL=" "$LPDEV_APP_PATH/.env" | cut -d'=' -f2- | tr -d '"')
        if [ -n "$app_url" ]; then
            echo ""
            print_info "Application available at: ${GREEN}$app_url${NC}"
        fi
    fi
}

start_dev() {
    eval $(get_current_project) || return 1
    
    # Parse arguments
    local exclude_services=""
    while [[ $# -gt 0 ]]; do
        case $1 in
            --exclude=*)
                exclude_services="${1#*=}"
                shift
                ;;
            --exclude)
                exclude_services="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done
    
    cd "$LPDEV_APP_PATH"

    # Check for default exclusions from project config if no --exclude argument provided
    if [ -z "$exclude_services" ]; then
        default_exclude=$(get_project_env "EXCLUDE" 2>/dev/null)
        if [ -n "$default_exclude" ]; then
            exclude_services="$default_exclude"
            print_info "Using default exclusions from project config: $exclude_services"
        fi
    fi
    
    print_header "Starting Development Environment"
    
    if [ -n "$exclude_services" ]; then
        print_info "Excluding services: $exclude_services"
    fi

    call_plugin_hook "before_start_dev" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
    
    # Check if concurrently is available
    if ! command -v npx &> /dev/null; then
        print_error "npx is not available. Please install Node.js/npm first."
        return 1
    fi

    # Helper function to check if service should be excluded
    is_excluded() {
        local service="$1"
        echo ",$exclude_services," | grep -q ",$service,"
    }
    
    # Check if pail is available (Laravel 11+)
    has_pail=false
    if php artisan list | grep -q "pail"; then
        has_pail=true
        print_info "Laravel Pail detected - will include log tailing"
    else
        print_warning "Laravel Pail not available"
    fi
    
    # Determine queue worker command
    queue_cmd=""
    
    if ! is_excluded "queue"; then
        # Check if Horizon is available
        if php artisan list | grep -q "horizon:work\|horizon$"; then
            # Use standard horizon for concurrently environment
            queue_cmd="php artisan horizon"
            
            # Check if spatie/laravel-horizon-watcher is installed for future manual use
            if ! composer show spatie/laravel-horizon-watcher >/dev/null 2>&1; then
                print_info "Installing spatie/laravel-horizon-watcher for manual horizon:watch usage..."
                composer require --dev spatie/laravel-horizon-watcher
                print_info "Laravel Horizon detected - using horizon (use 'lpdev horizon-watch' for file watching)"
            else
                print_info "Laravel Horizon detected - using horizon (use 'lpdev horizon-watch' for file watching)"
            fi
        else
            # Fall back to queue:listen with optional custom queue name
            queue_name=""
            # Check if there's a specific queue name configured
            custom_queue=$(get_project_env "QUEUE_NAME" 2>/dev/null)
            if [ -n "$custom_queue" ]; then
                queue_name="--queue=$custom_queue"
                print_info "Using custom queue: $custom_queue"
            fi
            queue_cmd="php artisan queue:listen $queue_name --tries=1"
            print_info "Using standard queue:listen for queue management"
        fi
    fi
    
    # Build arrays for concurrently
    local commands=()
    local colors=()
    local names=()
    
    # Add server if not excluded
    if ! is_excluded "server"; then
        commands+=("php artisan serve")
        colors+=("#93c5fd")
        names+=("server")
    fi
    
    # Add queue if not excluded
    if ! is_excluded "queue"; then
        commands+=("$queue_cmd")
        colors+=("#c4b5fd")
        names+=("queue")
    fi
    
    # Add logs (pail) if available and not excluded
    if [ "$has_pail" = true ] && ! is_excluded "logs"; then
        commands+=("php artisan pail --timeout=0")
        colors+=("#fb7185")
        names+=("logs")
    fi
    
    # Add Reverb (WebSocket server) if available and not excluded
    if ! is_excluded "reverb"; then
        # Check if Reverb is available
        if php artisan list | grep -q "reverb:start"; then
            commands+=("php artisan reverb:start")
            colors+=("#86efac")
            names+=("reverb")
            print_info "Laravel Reverb detected - will start WebSocket server"
        fi
    fi
    
    # Add vite if not excluded
    if ! is_excluded "vite"; then
        commands+=("cd $LPDEV_PACKAGE_PATH && npm run dev")
        colors+=("#fdba74")
        names+=("vite")
    fi
    
    # Check if we have any commands to run
    if [ ${#commands[@]} -eq 0 ]; then
        print_error "All services have been excluded. Nothing to start."
        return 1
    fi
    
    # Build the color string
    local color_string=$(IFS=,; echo "${colors[*]}")
    local names_string=$(IFS=,; echo "${names[*]}")
    
    # Show what's starting
    print_info "Starting: ${names_string//,/, }"
    
    # Run concurrently with dynamic commands
    npx concurrently \
        -c "$color_string" \
        "${commands[@]}" \
        --names="$names_string" \
        --kill-others

    call_plugin_hook "after_start_dev" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
}

stop_dev() {
    eval $(get_current_project) || return 1
    
    print_info "Stopping development servers..."

    call_plugin_hook "before_stop_dev" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
    
    # Kill all Laravel and npm processes
    pkill -f "artisan serve" 2>/dev/null
    pkill -f "artisan queue" 2>/dev/null
    pkill -f "artisan horizon" 2>/dev/null
    pkill -f "horizon:watch" 2>/dev/null
    pkill -f "artisan pail" 2>/dev/null
    pkill -f "artisan reverb" 2>/dev/null
    pkill -f "reverb:start" 2>/dev/null
    pkill -f "npm run dev" 2>/dev/null
    pkill -f "npm run start" 2>/dev/null
    pkill -f "vite" 2>/dev/null
    
    # Kill concurrently if it's running
    pkill -f "concurrently" 2>/dev/null
    
    # Additional cleanup for any remaining processes
    # Kill any remaining PHP built-in server
    pkill -f "php -S" 2>/dev/null
    
    # Kill any webpack or other bundlers
    pkill -f "webpack" 2>/dev/null
    
    print_success "Development servers stopped"

    call_plugin_hook "after_stop_dev" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
}

run_artisan() {
    eval $(get_current_project) || return 1
    
    call_plugin_hook "before_artisan" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH" "$@"

    cd "$LPDEV_APP_PATH"
    
    if [ $# -eq 0 ]; then
        echo -n "Enter artisan command: "
        read cmd
        php artisan $cmd
    else
        php artisan "$@"
    fi

    call_plugin_hook "after_artisan" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH" "$@"
}

clear_cache() {
    eval $(get_current_project) || return 1
    
    print_info "Clearing caches for $LPDEV_PROJECT..."

    call_plugin_hook "before_clear_cache" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
    
    cd "$LPDEV_APP_PATH"
    php artisan optimize:clear
    composer dump-autoload
    
    print_success "All caches cleared!"

    call_plugin_hook "after_clear_cache" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
}

publish_assets() {
    eval $(get_current_project) || return 1

    call_plugin_hook "before_publish_assets" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
    
    cd "$LPDEV_APP_PATH"
    
    # Try to detect service provider
    provider=$(echo "$LPDEV_PACKAGE_VENDOR" | sed 's|/|\\\\|g' | sed 's|-|\\\\|g')
    provider="${provider}\\\\ServiceProvider"
    
    print_info "Publishing assets..."
    php artisan vendor:publish --force
    
    print_success "Assets published!"
}

env_set() {
    eval $(get_current_project) || return 1
    
    if [ $# -lt 2 ]; then
        echo -n "Enter key: "
        read key
        echo -n "Enter value: "
        read value
    else
        key=$1
        value=$2
    fi
    
    # Set in app .env
    cd "$LPDEV_APP_PATH"
    set_env_var ".env" "$key" "$value"
    print_success "App: $key=$value"
    
    call_plugin_hook "on_env_set" "$key" "$value" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
}

run_tests() {
    eval $(get_current_project) || return 1
    
    call_plugin_hook "before_run_tests" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
    
    print_header "Running Tests for $LPDEV_PROJECT"
    
    # print_info "Running app tests..."
    # cd "$LPDEV_APP_PATH"
    # php artisan test
    
    print_info "Running package tests..."
    cd "$LPDEV_PACKAGE_PATH"
    if [ -f "vendor/bin/pest" ]; then
        ./vendor/bin/pest
    elif [ -f "vendor/bin/phpunit" ]; then
        ./vendor/bin/pest
    else
        print_warning "No test runner found in package"
    fi
    
    call_plugin_hook "after_run_tests" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
}

build_package() {
    eval $(get_current_project) || return 1
    
    call_plugin_hook "before_build_package" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
    
    print_info "Building package assets..."
    cd "$LPDEV_PACKAGE_PATH"
    npm run build
    
    print_success "Package built!"
    
    call_plugin_hook "after_build_package" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
}

quick_restart() {
    stop_dev
    clear_cache
    start_dev
}

horizon_watch() {
    eval $(get_current_project) || return 1
    
    call_plugin_hook "before_horizon_watch" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
    
    cd "$LPDEV_APP_PATH"
    
    # Check if Horizon is available
    if ! php artisan list | grep -q "horizon:work\|horizon$"; then
        print_error "Laravel Horizon is not installed"
        print_info "Install Horizon: composer require laravel/horizon"
        return 1
    fi
    
    # Check if spatie/laravel-horizon-watcher is installed
    if ! composer show spatie/laravel-horizon-watcher >/dev/null 2>&1; then
        print_info "Installing spatie/laravel-horizon-watcher..."
        composer require --dev spatie/laravel-horizon-watcher
    fi
    
    # Check if horizon:watch command is available
    if php artisan list | grep -q "horizon:watch"; then
        print_info "Starting Laravel Horizon with file watching..."
        print_info "This will restart Horizon when configuration files change"
        print_warning "Press Ctrl+C to stop"
        php artisan horizon:watch
    else
        print_error "horizon:watch command not available"
        print_info "Falling back to standard horizon"
        php artisan horizon
    fi
    
    call_plugin_hook "after_horizon_watch" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
}

ngrok_share() {
    eval $(get_current_project) || return 1
    
    call_plugin_hook "before_ngrok_share" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
    
    # Check if ngrok is available
    if ! command -v ngrok &> /dev/null; then
        print_error "ngrok is not installed or not in PATH"
        print_info "Install ngrok: https://ngrok.com/download"
        return 1
    fi
    
    print_info "Starting ngrok tunnel for $LPDEV_PROJECT..."
    
    # Check if Laravel server is running
    // TODO: Improve detection of Laravel server with function and with custom port support
    if ! pgrep -f "artisan serve" > /dev/null; then
        print_warning "Laravel server not detected. Starting it first..."
        cd "$LPDEV_APP_PATH"
        php artisan serve &
        laravel_pid=$!
        print_info "Laravel server started with PID: $laravel_pid"
        sleep 2 # Give server time to start
    fi
    
    # Get the port Laravel is running on (default 8000)
    laravel_port=8000
    if pgrep -f "artisan serve" > /dev/null; then
        # Try to detect the actual port from the process
        port_line=$(ps aux | grep "artisan serve" | grep -v grep | head -1)
        if [[ $port_line == *"--port="* ]]; then
            laravel_port=$(echo "$port_line" | sed 's/.*--port=\([0-9]*\).*/\1/')
        fi
    fi
    
    print_info "Detected Laravel running on port: $laravel_port"
    
    # Create a temporary file to capture ngrok output
    temp_file=$(mktemp)
    
    print_info "Running 'ngrok http $laravel_port' in background..."
    print_warning "This will start ngrok tunnel and monitor for the public URL..."
    
    # Run ngrok in background and capture output
    ngrok http $laravel_port > "$temp_file" 2>&1 &
    ngrok_pid=$!
    
    print_info "ngrok started with PID: $ngrok_pid"
    print_info "Monitoring for public URL (will wait up to 10 seconds)..."
    
    # Monitor the output file for public URL
    local count=0
    local max_attempts=20 # 10 seconds (20 * 0.5 seconds)
    share_url=""
    
    while [ $count -lt $max_attempts ]; do
        # Check ngrok API for tunnel info (more reliable than parsing output)
        if command -v curl &> /dev/null; then
            tunnel_info=$(curl -s http://localhost:4040/api/tunnels 2>/dev/null)
            if [ -n "$tunnel_info" ]; then
                share_url=$(echo "$tunnel_info" | grep -oE 'https://[a-zA-Z0-9.-]+\.ngrok\.io' | head -1)
                if [ -n "$share_url" ]; then
                    break
                fi
            fi
        fi
        
        # Fallback: try to parse log file
        if [ -f "$temp_file" ] && [ -z "$share_url" ]; then
            share_url=$(grep -oE 'https://[a-zA-Z0-9.-]+\.ngrok\.io' "$temp_file" 2>/dev/null | head -1)
            if [ -n "$share_url" ]; then
                break
            fi
        fi
        
        # Check if the process is still running
        if ! kill -0 $ngrok_pid 2>/dev/null; then
            print_error "ngrok process died unexpectedly"
            cat "$temp_file"
            rm -f "$temp_file"
            return 1
        fi
        
        sleep 0.5
        count=$((count + 1))
        
        # Show progress dots
        if [ $((count % 4)) -eq 0 ]; then
            echo -n "."
        fi
    done
    
    echo "" # New line after progress dots
    
    if [ -n "$share_url" ]; then
        print_success "ngrok tunnel started successfully!"
        print_info "Public URL: ${GREEN}$share_url${NC}"
        print_info "ngrok is running in background (PID: $ngrok_pid)"
        print_info "Local URL: http://localhost:$laravel_port"
        
        # Backup current APP_URL before changing it
        cd "$LPDEV_APP_PATH"
        if [ -f ".env" ]; then
            current_app_url=$(grep "^APP_URL=" .env | cut -d'=' -f2- | tr -d '"' 2>/dev/null)
            if [ -n "$current_app_url" ]; then
                echo "$current_app_url" > "$CONFIG_DIR/ngrok_share_original_url"
                print_info "Backed up original APP_URL: $current_app_url"
            fi
        fi
        
        # Update APP_URL in environment
        print_info "Updating APP_URL to public URL..."
        
        # Set APP_URL in app .env
        set_env_var "$LPDEV_APP_PATH/.env" "APP_URL" "$share_url"
        print_success "APP_URL updated to: $share_url"
        print_info "Your Laravel app is now publicly accessible!"
        
        # Save PID and share URL for potential cleanup
        echo "$ngrok_pid" > "$CONFIG_DIR/ngrok_share_pid"
        echo "$share_url" > "$CONFIG_DIR/ngrok_share_url"
        
        print_info "To stop ngrok later, run: kill $ngrok_pid"
        print_info "Or use: lpdev share-stop"
        print_info "View ngrok dashboard: http://localhost:4040"
        
        # Call plugin hook for ngrok share
        call_plugin_hook "on_ngrok_share" "$share_url" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
    else
        print_warning "Could not detect ngrok public URL within 10 seconds"
        print_info "ngrok may still be starting up. Check the output:"
        
        if [ -f "$temp_file" ]; then
            echo -e "${CYAN}ngrok output:${NC}"
            cat "$temp_file"
        fi
        
        print_info "ngrok is still running (PID: $ngrok_pid)"
        print_info "You can monitor it manually or kill it with: kill $ngrok_pid"
        print_info "Try accessing ngrok dashboard: http://localhost:4040"
        
        # Save PID anyway
        echo "$ngrok_pid" > "$CONFIG_DIR/ngrok_share_pid"
    fi
    
    # Clean up temp file
    rm -f "$temp_file"
}

ngrok_share_stop() {
    eval $(get_current_project) || return 1
    
    call_plugin_hook "before_ngrok_share_stop" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
    
    print_info "Stopping ngrok tunnel for $LPDEV_PROJECT..."
    
    # Check if PID file exists
    pid_file="$CONFIG_DIR/ngrok_share_pid"
    
    if [ ! -f "$pid_file" ]; then
        print_warning "No ngrok PID file found"
        print_info "Attempting to find and kill ngrok processes..."
        
        # Try to kill any ngrok processes
        if pgrep -f "ngrok http" > /dev/null; then
            pkill -f "ngrok http"
            print_success "Killed ngrok processes"
            
            # Try to restore original URL if backup exists
            original_url_file="$CONFIG_DIR/ngrok_share_original_url"
            if [ -f "$original_url_file" ]; then
                original_url=$(cat "$original_url_file")
                if [ -n "$original_url" ]; then
                    print_info "Restoring original APP_URL: $original_url"
                    
                    # Restore APP_URL in app .env
                    set_env_var "$LPDEV_APP_PATH/.env" "APP_URL" "$original_url"
                    print_success "APP_URL restored to: $original_url"
                    
                    # Clean up backup files
                    rm -f "$original_url_file"
                    rm -f "$CONFIG_DIR/ngrok_share_url"
                fi
            fi
        else
            print_info "No ngrok processes found"
        fi
        return
    fi
    
    ngrok_pid=$(cat "$pid_file")
    
    if [ -n "$ngrok_pid" ]; then
        if kill -0 "$ngrok_pid" 2>/dev/null; then
            print_info "Stopping ngrok process (PID: $ngrok_pid)..."
            kill "$ngrok_pid" 2>/dev/null
            
            # Wait a moment and check if it's really dead
            sleep 1
            if kill -0 "$ngrok_pid" 2>/dev/null; then
                print_warning "Process still running, forcing kill..."
                kill -9 "$ngrok_pid" 2>/dev/null
            fi
            
            print_success "ngrok tunnel stopped"
        else
            print_info "ngrok process (PID: $ngrok_pid) was already stopped"
        fi
        
        # Remove PID file
        rm -f "$pid_file"
        
        # Restore original APP_URL if we have a backup
        original_url_file="$CONFIG_DIR/ngrok_share_original_url"
        if [ -f "$original_url_file" ]; then
            original_url=$(cat "$original_url_file")
            if [ -n "$original_url" ]; then
                print_info "Restoring original APP_URL: $original_url"
                
                # Restore APP_URL in app .env
                set_env_var "$LPDEV_APP_PATH/.env" "APP_URL" "$original_url"
                print_success "APP_URL restored to: $original_url"
                
                # Clean up backup files
                rm -f "$original_url_file"
                rm -f "$CONFIG_DIR/ngrok_share_url"
            fi
        else
            print_warning "No original APP_URL backup found"
            print_info "You may need to manually restore your APP_URL"
        fi
    else
        print_error "Invalid PID in file"
        rm -f "$pid_file"
    fi
    
    call_plugin_hook "after_ngrok_share_stop" "$LPDEV_APP_PATH" "$LPDEV_PACKAGE_PATH"
}

show_status() {
    print_header "LPDEV Status"
    
    current=$(cat "$CURRENT_PROJECT_FILE" 2>/dev/null)
    if [ -z "$current" ]; then
        print_warning "No project selected"
        echo ""
        list_projects
        return
    fi
    
    eval $(get_current_project) || return 1
    
    echo -e "${BOLD}Current Project:${NC} ${GREEN}$LPDEV_PROJECT${NC}"
    echo -e "${BOLD}App Path:${NC} $LPDEV_APP_PATH"
    echo -e "${BOLD}Package Path:${NC} $LPDEV_PACKAGE_PATH"
    echo -e "${BOLD}Package Vendor:${NC} $LPDEV_PACKAGE_VENDOR"
    
    # Check if package is linked
    if [ -L "$LPDEV_PACKAGE_VENDOR_PATH" ]; then
        echo -e "${BOLD}Package Status:${NC} ${GREEN}Linked (Development Mode)${NC}"
    else
        echo -e "${BOLD}Package Status:${NC} ${YELLOW}Composer Package${NC}"
    fi
    
    # Show running servers with detailed information
    echo ""
    show_running_servers
}

exec_in_app() {
    eval $(get_current_project) || return 1
    cd "$LPDEV_APP_PATH"
    "$@"
}

exec_in_package() {
    eval $(get_current_project) || return 1
    cd "$LPDEV_PACKAGE_PATH"
    "$@"
}

show_laravel_versions() {
    eval $(get_current_project) || return 1
    
    echo -e "${BOLD}${BLUE}Laravel Versions${NC}"
    echo ""
    
    # Check Laravel version in app
    echo -e "${BOLD}Application (${LPDEV_APP_PATH##*/}):${NC}"
    if [ -f "$LPDEV_APP_PATH/composer.json" ]; then
        cd "$LPDEV_APP_PATH"
        
        # Try to get version from artisan command first (most accurate)
        if [ -f "$LPDEV_APP_PATH/artisan" ]; then
            version=$(php artisan --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
            if [ -n "$version" ]; then
                echo -e "  ${GREEN}Laravel ${version}${NC} (installed)"
            else
                # Fallback to composer.json requirement
                version=$(grep -A1 '"laravel/framework"' composer.json | grep -oE '[0-9]+\.[0-9]+' | head -1)
                if [ -n "$version" ]; then
                    echo -e "  ${YELLOW}Laravel ^${version}${NC} (composer requirement)"
                else
                    echo -e "  ${RED}Laravel version not found${NC}"
                fi
            fi
        else
            echo -e "  ${RED}artisan file not found${NC}"
        fi
        
        # Check actual installed Laravel framework version with composer show
        if [ -d "$LPDEV_APP_PATH/vendor" ]; then
            installed_laravel=$(composer show laravel/framework 2>/dev/null | grep "versions" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
            if [ -n "$installed_laravel" ]; then
                echo -e "  ${CYAN}Composer: ${installed_laravel}${NC} (installed)"
            fi
        fi
    else
        echo -e "  ${RED}composer.json not found${NC}"
    fi
    
    echo ""
    
    # Check Laravel version in package
    echo -e "${BOLD}Package (${LPDEV_PACKAGE_PATH##*/}):${NC}"
    if [ -f "$LPDEV_PACKAGE_PATH/composer.json" ]; then
        cd "$LPDEV_PACKAGE_PATH"
        
        # Check for Laravel requirement in composer.json
        laravel_req=$(grep -A1 '"laravel/framework"' composer.json 2>/dev/null | grep -oE '"[^"]+"' | tail -1 | tr -d '"')
        if [ -n "$laravel_req" ]; then
            echo -e "  ${GREEN}Laravel ${laravel_req}${NC} (requirement)"
        else
            # Check for illuminate packages as alternative
            illuminate_version=$(grep -E '"illuminate/[^"]+"\s*:' composer.json 2>/dev/null | head -1 | grep -oE '"[^"]+"' | tail -1 | tr -d '"')
            if [ -n "$illuminate_version" ]; then
                echo -e "  ${GREEN}Illuminate ${illuminate_version}${NC} (requirement)"
            else
                echo -e "  ${YELLOW}No Laravel/Illuminate requirement found${NC}"
            fi
        fi
        
        # Check actual installed Laravel/Illuminate version using composer show
        if [ -d "$LPDEV_PACKAGE_PATH/vendor" ]; then
            # Try to get Laravel framework version
            laravel_installed=$(composer show laravel/framework 2>/dev/null | grep "versions" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
            if [ -n "$laravel_installed" ]; then
                echo -e "  ${CYAN}Laravel ${laravel_installed}${NC} (installed)"
            else
                # Try to get any illuminate package version as fallback
                illuminate_installed=$(composer show 'illuminate/*' 2>/dev/null | head -1 | awk '{print $1, $2}')
                if [ -n "$illuminate_installed" ]; then
                    # Get just the first illuminate package to show the version
                    first_pkg=$(echo "$illuminate_installed" | head -1)
                    pkg_name=$(echo "$first_pkg" | awk '{print $1}' | sed 's/illuminate\///')
                    pkg_version=$(echo "$first_pkg" | awk '{print $2}')
                    echo -e "  ${CYAN}Illuminate ${pkg_version}${NC} (installed - ${pkg_name})"
                fi
            fi
        fi
        
        # Check PHP requirement
        php_req=$(grep '"php"' composer.json 2>/dev/null | grep -oE '"[^"]+"' | tail -1 | tr -d '"')
        if [ -n "$php_req" ]; then
            echo -e "  ${BLUE}PHP ${php_req}${NC} (requirement)"
        fi
    else
        echo -e "  ${RED}composer.json not found${NC}"
    fi
    
    echo ""
    
    # Show current PHP version for reference
    php_version=$(php -v 2>/dev/null | head -1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    if [ -n "$php_version" ]; then
        echo -e "${BOLD}System:${NC}"
        echo -e "  ${BLUE}PHP ${php_version}${NC} (installed)"
    fi
}

show_help() {
    echo -e "${BOLD}${BLUE}Laravel Package Development CLI${NC}

${BOLD}USAGE:${NC}
    lpdev <command> [options]

${BOLD}PROJECT MANAGEMENT:${NC}
    ${GREEN}add${NC}              Add a new project
    ${GREEN}list${NC}             List all projects
    ${GREEN}switch${NC}           Switch between projects
    ${GREEN}remove${NC}           Remove a project
    ${GREEN}status${NC}           Show current project status
    ${GREEN}env-set${NC} <key> <val> Set lpdev project environment variable (e.g., EXCLUDE, QUEUE_NAME)
    ${GREEN}env-remove${NC} <key>   Remove lpdev project environment variable  
    ${GREEN}env-list${NC}           List all lpdev project environment variables

${BOLD}DEVELOPMENT:${NC}
    ${GREEN}link${NC}             Link local package for development
    ${GREEN}unlink${NC}           Restore package from composer
    ${GREEN}branch${NC} <name>    Switch package branch in application composer.json
    ${GREEN}install${NC}          Install all dependencies (app + package)
    ${GREEN}start${NC}            Start development servers (basic)
    ${GREEN}dev${NC} [--exclude=services] Start full dev environment (server, queue, logs, vite, package)
    ${GREEN}horizon-watch${NC}    Start Horizon with file watching (interactive)
    ${GREEN}stop${NC}             Stop all development servers
    ${GREEN}restart${NC}          Quick restart (stop, clear cache, start)
    ${GREEN}fresh${NC}            Complete fresh install (link, branch, deps, cache)
    ${GREEN}test${NC}             Run tests

${BOLD}LARAVEL COMMANDS:${NC}
    ${GREEN}artisan${NC} <cmd>    Run artisan command
    ${GREEN}clear${NC}            Clear all caches
    ${GREEN}fresh-db${NC}         Fresh migration with seeders
    ${GREEN}migrate${NC}          Run migrations
    ${GREEN}tinker${NC}           Start tinker session

${BOLD}PACKAGE COMMANDS:${NC}
    ${GREEN}build${NC}            Build package assets
    ${GREEN}publish${NC}          Publish package assets

${BOLD}UTILITIES:${NC}
    ${GREEN}env${NC} <key> <val>          Set Laravel .env variable
    ${GREEN}app${NC} <cmd>          Execute command in app directory
    ${GREEN}pkg${NC} <cmd>          Execute command in package directory
    ${GREEN}share${NC}              Share app via ngrok tunnel (updates APP_URL)
    ${GREEN}share-stop${NC}         Stop ngrok tunnel and restore APP_URL
    ${GREEN}logs${NC}               Tail Laravel logs
    ${GREEN}laravel-versions${NC}   Show Laravel versions in app and package

${BOLD}PLUGINS:${NC}
    ${GREEN}plugin list${NC}      List installed plugins  
    ${GREEN}plugin install${NC}   Install plugin from npm
    ${GREEN}plugin enable${NC}    Enable an installed plugin
    ${GREEN}plugin disable${NC}   Disable a plugin
    ${GREEN}plugin${NC} <name> <cmd> Execute plugin command

${BOLD}EXAMPLES:${NC}
    lpdev add                     # Add new project interactively
    lpdev switch myproject        # Switch to project
    lpdev dev                     # Start full dev environment (respects LPDEV_EXCLUDE in .env)
    lpdev dev --exclude=queue     # Start without queue worker
    lpdev dev --exclude=queue,logs # Start without queue and logs
    lpdev share                   # Share app publicly via ngrok
    lpdev artisan migrate         # Run migrations
    lpdev app npm install axios   # Install npm package in app
    lpdev pkg npm run build       # Build package assets"
}

# Main script
init_config
load_plugins

# Handle commands
# Store the command for display
COMMAND_NAME="${1:-help}"

# Show command start (skip for help and project management commands that don't need project context)
case "$COMMAND_NAME" in
    help|h|--help|-h|add|list|ls|switch|sw|remove|rm|status) ;;
    *) show_command_start "$COMMAND_NAME" ;;
esac

case "${1:-help}" in
    # Project management
    add) add_project ;;
    list|ls) list_projects ;;
    switch|sw) switch_project ;;
    remove|rm) remove_project ;;
    status|st) show_status ;;
    env-set) shift; set_project_env "$@" ;;
    env-remove|lpdev-env-rm) shift; remove_project_env "$@" ;;
    env-list|lpdev-env-ls) list_project_env ;;
    
    # Development
    link) link_package ;;
    unlink) unlink_package ;;
    branch|br) switch_branch "$2" ;;
    install|i) install_deps ;;
    dev|up) shift; start_dev "$@" ;;
    stop|down) stop_dev ;;
    restart) quick_restart ;;
    horizon-watch) horizon_watch ;;
    
    # Laravel commands
    artisan|a) shift; run_artisan "$@" ;;
    clear|cache) clear_cache ;;
    fresh) fresh_install ;;
    fresh-db) run_artisan "migrate:fresh" "--seed" ;;
    migrate|m) run_artisan "migrate" ;;
    tinker|t) run_artisan "tinker" ;;
    laravel-versions|versions) show_laravel_versions ;;
    test) run_tests ;;
    
    # Package commands
    build) build_package ;;
    publish|pub) publish_assets ;;
    
    # Utilities
    env) shift; env_set "$@" ;;
    app) shift; exec_in_app "$@" ;;
    pkg) shift; exec_in_package "$@" ;;
    share) ngrok_share ;;
    share-stop) ngrok_share_stop ;;
    logs|log) 
        eval $(get_current_project) || exit 1
        tail -f "$LPDEV_APP_PATH/storage/logs/laravel.log" 
        ;;
    
    # Plugin commands
    plugin)
        shift
        case "$1" in
            list)
                plugin_list
                ;;
            install)
                plugin_install "$2"
                ;;
            uninstall|remove)
                plugin_uninstall "$2"
                ;;
            enable)
                plugin_enable "$2"
                ;;
            disable)
                plugin_disable "$2"
                ;;
            search)
                plugin_search "$2"
                ;;
            *)
                # Execute plugin command
                plugin_name="$1"
                shift
                
                if [ -z "$plugin_name" ]; then
                    plugin_help
                    exit 1
                fi
                
                # Check if plugin is enabled
                if [ ! -f "$PLUGINS_ENABLED_DIR/${plugin_name}.plugin" ] && [ ! -L "$PLUGINS_ENABLED_DIR/${plugin_name}.plugin" ]; then
                    print_error "Plugin '$plugin_name' is not enabled"
                    print_info "Try: lpdev plugin enable $plugin_name"
                    exit 1
                fi
                
                # Source the plugin and pass remaining arguments
                source "$PLUGINS_ENABLED_DIR/${plugin_name}.plugin"
                "$@"
                ;;
        esac
        ;;
    
    # Help
    help|h|--help|-h) show_help ;;
    
    *)
        print_error "Unknown command: $1"
        echo "Run 'lpdev help' for usage information"
        exit 1
        ;;
esac

# Show command end (skip for help and project management commands that don't need project context)
case "$COMMAND_NAME" in
    help|h|--help|-h|add|list|ls|switch|sw|remove|rm|status) ;;
    *) show_command_end "$COMMAND_NAME" ;;
esac